# 08. 그래프

## 08-1. 그래프의 표현

### 에지 리스트

에지 리스트(edge list)는 에지를 중심으로 그래프를 표현한다. 배열에 출발 노드, 도착 노드를 지정하여 에지를 표현한다. 또는 가중치까지 저장하여 가중치가 있는 에지를 표현할 수도 있다.

#### 에지 리스트로 가중치 없는 그래프 표현하기

출발 노드와 도착 노드만 표현하므로 2개의 열로 충분하다.

#### 에지 리스트로 가중치 있는 그래프 표현하기

가중치가 있는 그래프는 가중치를 저장하기 위한 열을 추가하여 3개의 열을 사용하면 된다.

에지 리스트는 노드 사이의 최단 거리를 구하는 벨만-포드나 최소 신장 트리를 찾는 크루스칼 알고리즘에 사용하며, 노드 중심 알고리즘에는 잘 사용하지 않는다.

### 인접 행렬

인접 행렬(adjacency matrix)은 2차원 배열을 자료구조로 이용하여 그래프를 표현한다. 에지 리스트와 다르게 노드 중심으로 그래프를 표현한다.

#### 인접 행렬로 가중치 없는 그래프 표현하기

2차원 배열을 bool 형으로 선언해도 된다. `matrix[출발 노드][도착 노드]`에 그러한 에지가 존재하는지 안 하는지만 나타내면 되기 때문이다.

#### 인접 행렬로 가중치 있는 그래프 표현하기

2차원 배열을 숫자 자료형으로 선언하여 셀에 에지의 가중치를 기록한다.

인접 행렬을 이용한 그래프 구현은 쉽지만 인접 리스트에 비해 시간 복잡도가 느리고 노드 개수에 비해 에지가 적을 때에는 공간 효율성이 떨어진다.

### 인접 리스트

C++의 인접 리스트(adjacency list)는 이차원 벡터로 그래프를 표현한다.

#### 인접 리스트로 가중치 없는 그래프 표현하기

가중치 없는 그래프의 경우 vector<vector<int>> 형의 그래프에 노드 번호만 삽입하면 된다.

#### 인접 리스트로 가중치 있는 그래프 표현하기

가중치 있는 그래프의 경우 vector<vector<pair<int, int>>> 형의 그래프에 노드 번호와 가중치를 삽입하면 된다.

## 08-2. 유니온 파인드

유니온 파인드(union-find)는 일반적으로 여러 노드가 있을 때 특정 노드 2개를 연결해 1개의 집합으로 묶는 union 연산과 두 노드가 같은 집합에 속해 있는지를 확인하는 find 연산으로 구성된 알고리즘이다.

### 유니온 파인드의 핵심 이론

- `union 연산`: 각 노드가 속한 집합을 1개로 합치는 연산이다. 노드 a, b가 a ∈ A, b ∈ B일 때 union(a, b)는 A ∪ B를 의미한다.
- `find 연산`: 특정 노드 a에 관해 a가 속한 집합의 대표 노드를 반환하는 연산이다. 노드 a가 a ∈ A일 때 find(a)는 A 집합의 대표 노드를 반환한다.

#### 유니온 파인드의 원리 이해하기

유니온 파인드 알고리즘의 구현 방법은 다음과 같다.

1. 일반적으로 1차원 배열을 사용해 유니온 파인드를 표현한다. 인덱스는 노드의 번호를 의미하고, 배열의 값은 해당 노드가 속한 그룹의 대표 노드의 번호를 나타낸다. 초기에는 배열의 모든 값이 인덱스와 동일하게 초기화된다.
2. union 연산 시 배열의 두 개 인덱스의 값이 일치하게 된다. 예를 들어 union(1, 4) 수행 이후 array[1] == array[4] == 1이 되고, union(5, 6) 수행 이후 array[5] == array[6] == 5가 되는 식이다. 이후 union(4, 6)을 수행할 때는 다른 방식이 적용되는데, 6이 속한 그룹의 대표 노드는 6이 아니고 4가 속한 그룹의 대표 노드는 4가 아니다. 따라서 배열을 거슬러 올라가 1, 5를 찾아야 한다. 이후 5가 속한 그룹을 1이 속한 그룹으로 수정해 주면 된다.
3. find 연산은 자신이 속한 집합의 대표 노드를 찾는 연산이다. 이는 단순히 대표 노드를 찾는 역할만 하지 않고 그래프를 정돈하여 시간 복잡도를 줄여주기도 한다. find 연산의 작동 원리는 다음과 같다.
   1. 배열에서 대상 노드의 index 값과 value 값이 동일한지 확인한다.
   2. 동일하지 않으면 value 값이 가리키는 index 위치로 이동한다.
   3. 이동 위치의 index 값과 value 값이 같을 때까지 1~2를 반복한다. 이 부분은 재귀 함수 또는 스택으로 구현된다.
   4. 대표 노드에 도달하면 반복을 빠져 나오면서 거쳐가는 모든 노드의 값을 대표 노드의 값으로 변경한다.

find 연산 수행 시 같은 집합 내에 있는 모든 노드의 깊이가 재정렬되기 때문에 연속으로 같은 집합의 노드에 대해 find 연산을 수행할 경우 시간 복잡도가 O(1)로 고정된다.

## 08-3. 위상 정렬

위상 정렬(topology sort)은 사이클이 없는 방향 그래프에서 노드 순서를 찾는 알고리즘이다.

| 기능 | 특징 | 시간 복잡도(노드 수: V, 에지 수: E) |
| :-- | :-- | :-- |
| 노드 간의 순서를 결정 | 사이클이 없어야 함 | O(V + E) |

위상 정렬에서는 항상 유일한 값으로 정렬되지 않는다. 또한 사이클이 존재하면 노드 간의 순서를 명확하게 정의할 수 없으므로 위상 정렬을 적용할 수 없다.

### 위상 정렬의 핵심 이론

#### 위상 정렬의 원리 이해하기

1. 진입 차수(in-degree)는 자기 자신을 가리키는 에지의 개수이다. 진입 차수 배열 D를 정의하고, 에지를 추가할 때마다 도착 노드의 진입 차수 배열 값을 1씩 더한다.
2. 진입 차수 배열에서 진입 차수가 0인 노드를 선택하고 선택된 노드를 정렬 배열에 저장한다. 그 후 인접 리스트에서 선택된 노드가 가리키는 노드들의 진입 차수를 1씩 뺀다. 그 다음으로 선택된 노드가 가리키는 노드들을 기준으로 다시 그 노드가 가리키는 노드들의 진입 차수를 1씩 빼는 것을 반복한다. 이때 어떤 노드를 먼저 선택하냐에 따라 정렬 방식이 바뀔 수 있기 때문에 위상 정렬에서는 항상 유일한 값으로 정렬되지 않는다.

## 08-4. 다익스트라

다익스트라(dijkstra) 알고리즘은 그래프에서 최단 거리를 구하는 알고리즘이다.

| 기능 | 특징 | 시간 복잡도(노드 수: V, 에지 수: E) |
| :-- | :-- | :-- |
| 출발 노드와 모든 노드 간의 최단 거리 탐색 | 에지의 가중치는 모두 양수 | O(ElogV) |

### 다익스트라 알고리즘의 핵심 이론

1. 인접 리스트로 그래프 구현하기
2. 최단 거리 배열 초기화하기: 출발 노드는 0, 이외의 노드는 무한으로 초기화한다. 이때 무한은 충분히 큰 값으로 설정하면 된다.
3. 값이 가장 작은 노드 고르기: 최단 거리 배열에서 현재 값이 가장 작은 노드를 고른다.
4. 최단 거리 배열 업데이트하기: 선택된 노드에 연결된 에지의 값을 바탕으로 다른 노드의 값을 업데이트한다. `min(선택 노드의 최단 거리 배열 값 + 에지 가중치, 연결 노드의 최단 거리 배열 값)`을 저장하면 된다.
5. 과정 3~4를 반복해 최단 거리 배열 완성하기: 모든 노드가 처리될 때까지 과정 3~4를 반복한다. 한 번 선택된 노드는 다시 선택되지 않도록 방문 배열을 활용한다.

다익스트라 알고리즘은 단순히 출발 노드에서 어느 특정한 도착 노드까지의 최단 거리를 구하는 알고리즘이 아닌 모든 노드까지의 최단 거리를 구하는 알고리즘이다.

## 08-5. 벨만-포드

벨만-포드(bellman-ford-moore) 알고리즘은 그래프에서 최단 거리를 구하는 알고리즘이다.

| 기능 | 특징 | 시간 복잡도(노드 수: V, 에지 수: E) |
| :-- | :-- | :-- |
| 특정 출발 노드에서 다른 모든 노드까지의 최단 경로 탐색 | 1. 음수 가중치 에지가 있어도 수행할 수 있음<br/>2. 전체 그래프에서 음수 사이클의 존재 여부를 판단할 수 있음 | O(VE) |

### 벨만-포드의 핵심 이론

벨만-포드 알고리즘은 다음 3단계의 원리로 동작한다.

1. 에지 리스트로 그래프를 구현하고 최단 경로 배열 초기화하기: 벨만-포드 알고리즘은 에지를 중심으로 동작하므로 그래프를 에지 리스트로 구현한다.
2. 모든 에지를 확인해 정답 배열 업데이트하기: 최단 거리 배열에서 업데이트 반복 횟수는 노드 개수 - 1이다. 노드 개수가 N이고 음수 사이클이 없을 때 특정 두 노드의 최단 거리를 구성할 수 있는 에지의 최대 개수는 N - 1개이기 때문이다. 모든 에지 E = (s, e, w)에서 `D[s] != INF && D[e] > D[s] + w`일 때 `D[e] = D[s] + w`로 배열의 값을 업데이트한다. 음수 사이클이 없을 때 N - 1번 에지 사용 횟수를 반복하면 출발 노드와 모든 노드 간의 최단 거리가 완성된다.
3. 음수 사이클 유무 확인하기: 음수 사이클 유무를 확인하기 위해 모든 에지를 한 번씩 다시 사용해 업데이트되는 노드가 발생하는지 확인한다. 만약 업데이트되는 노드가 있다면 음수 사이클이 있다는 의미가 되고, 이는 최단 거리를 찾을 수 없는 그래프라는 의미이다.

## 08-6. 플로이드-워셜

플로이드-워셜(floyd-warshall) 알고리즘은 그래프에서 최단 거리를 구하는 알고리즘으로 주요 특징은 다음과 같다.

| 기능 | 특징 | 시간 복잡도(노드 수: V) |
| :-- | :-- | :-- |
| 모든 노드 간에 최단 경로 탐색 | 1. 음수 가중치 에지가 있어도 수행할 수 있음<br/>2. 동적 계획법의 원리를 이용해 알고리즘에 접근 | O(V³) |

### 플로이드-워셜의 핵심 이론

가장 핵심적인 원리는 A 노드에서 B 노드까지 최단 경로를 구했다고 가정했을 때 최단 경로 위에 K 노드가 존재한다면 그것을 이루는 부분 경로 역시 최단 경로라는 것이다. 이 원리로 `D[S][E] = min(D[S][E], D[S][K] + D[K][E])`라는 점화식을 도출할 수 있다.

구현 방법은 다음과 같다.

1. 배열을 선언하고 초기화하기: 인접 행렬 그래프에서 대각 성분은 0, 나머지는 INF로 초기화한다.
2. 최단 거리 배열에 그래프 데이터 저장하기: 출발 노드 S, 도착 노드 E, 에지의 가중치 W에 대해 `D[S][E] = W`처럼 저장한다.
3. 점화식으로 배열 업데이트하기: 점화식을 3중 for문의 형태로 반복하면서 배열의 값을 업데이트한다.

```
for 경유지 K에 관해 (1 ~ N)
   for 출발 노드 S에 관해 (1 ~ N)
      for 도착 노드 E에 관해 (1 ~ N)
         D[S][E] = min(D[S][E], D[S][K] + D[K][E])
```

## 08-7. 최소 신장 트리

최소 신장 트리(minimum spanning tree)는 그래프에서 모든 노드를 연결할 때 사용된 에지들의 가중치 합을 최소로 하는 트리이다. 주요 특징은 다음과 같다.

- 사이클이 포함되면 가중치의 합이 최소가 될 수 없으므로 사이클을 포함하지 않는다.
- N개의 노드가 있을 때 최소 신장 트리르 구성하는 에지의 개수는 항상 N-1개이다.

### 최소 신장 트리의 핵심 이론

1. 에지 리스트로 그래프를 구현하고 유니온 파인드 배열 초기화하기: 최소 신장 트리는 에지 중심이므로 그래프를 에지 리스트로 구현한다. 유니온 파인드 배열은 사이클 처리를 위해 사용된다.
2. 그래프 데이터를 가중치 기준으로 정렬하기: 에지 리스트에 담긴 그래프 데이터를 가중치 기준으로 오름차순 정렬한다.
3. 가중치가 낮은 에지부터 연결 시도하기: 가중치가 낮은 에지부터 순서대로 연결을 시도한다. 이때 에지의 두 노드에 find 연산을 수행해서 대표 노드가 다를 시에만 연결이 성립된다.
4. 과정 3 반복하기: 연결한 에지의 개수가 N-1개가 될 때까지 과정 3을 반복한다.
5. 총 에지 비용 출력하기