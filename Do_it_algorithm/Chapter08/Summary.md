# 08. 그래프

## 08-1. 그래프의 표현

### 에지 리스트

에지 리스트(edge list)는 에지를 중심으로 그래프를 표현한다. 배열에 출발 노드, 도착 노드를 지정하여 에지를 표현한다. 또는 가중치까지 저장하여 가중치가 있는 에지를 표현할 수도 있다.

#### 에지 리스트로 가중치 없는 그래프 표현하기

출발 노드와 도착 노드만 표현하므로 2개의 열로 충분하다.

#### 에지 리스트로 가중치 있는 그래프 표현하기

가중치가 있는 그래프는 가중치를 저장하기 위한 열을 추가하여 3개의 열을 사용하면 된다.

에지 리스트는 노드 사이의 최단 거리를 구하는 벨만-포드나 최소 신장 트리를 찾는 크루스칼 알고리즘에 사용하며, 노드 중심 알고리즘에는 잘 사용하지 않는다.

### 인접 행렬

인접 행렬(adjacency matrix)은 2차원 배열을 자료구조로 이용하여 그래프를 표현한다. 에지 리스트와 다르게 노드 중심으로 그래프를 표현한다.

#### 인접 행렬로 가중치 없는 그래프 표현하기

2차원 배열을 bool 형으로 선언해도 된다. `matrix[출발 노드][도착 노드]`에 그러한 에지가 존재하는지 안 하는지만 나타내면 되기 때문이다.

#### 인접 행렬로 가중치 있는 그래프 표현하기

2차원 배열을 숫자 자료형으로 선언하여 셀에 에지의 가중치를 기록한다.

인접 행렬을 이용한 그래프 구현은 쉽지만 인접 리스트에 비해 시간 복잡도가 느리고 노드 개수에 비해 에지가 적을 때에는 공간 효율성이 떨어진다.

### 인접 리스트

C++의 인접 리스트(adjacency list)는 이차원 벡터로 그래프를 표현한다.

#### 인접 리스트로 가중치 없는 그래프 표현하기

가중치 없는 그래프의 경우 vector<vector<int>> 형의 그래프에 노드 번호만 삽입하면 된다.

#### 인접 리스트로 가중치 있는 그래프 표현하기

가중치 있는 그래프의 경우 vector<vector<pair<int, int>>> 형의 그래프에 노드 번호와 가중치를 삽입하면 된다.

## 08-2. 유니온 파인드

유니온 파인드(union-find)는 일반적으로 여러 노드가 있을 때 특정 노드 2개를 연결해 1개의 집합으로 묶는 union 연산과 두 노드가 같은 집합에 속해 있는지를 확인하는 find 연산으로 구성된 알고리즘이다.

### 유니온 파인드의 핵심 이론

- `union 연산`: 각 노드가 속한 집합을 1개로 합치는 연산이다. 노드 a, b가 a ∈ A, b ∈ B일 때 union(a, b)는 A ∪ B를 의미한다.
- `find 연산`: 특정 노드 a에 관해 a가 속한 집합의 대표 노드를 반환하는 연산이다. 노드 a가 a ∈ A일 때 find(a)는 A 집합의 대표 노드를 반환한다.

#### 유니온 파인드의 원리 이해하기

유니온 파인드 알고리즘의 구현 방법은 다음과 같다.

1. 일반적으로 1차원 배열을 사용해 유니온 파인드를 표현한다. 인덱스는 노드의 번호를 의미하고, 배열의 값은 해당 노드가 속한 그룹의 대표 노드의 번호를 나타낸다. 초기에는 배열의 모든 값이 인덱스와 동일하게 초기화된다.
2. union 연산 시 배열의 두 개 인덱스의 값이 일치하게 된다. 예를 들어 union(1, 4) 수행 이후 array[1] == array[4] == 1이 되고, union(5, 6) 수행 이후 array[5] == array[6] == 5가 되는 식이다. 이후 union(4, 6)을 수행할 때는 다른 방식이 적용되는데, 6이 속한 그룹의 대표 노드는 6이 아니고 4가 속한 그룹의 대표 노드는 4가 아니다. 따라서 배열을 거슬러 올라가 1, 5를 찾아야 한다. 이후 5가 속한 그룹을 1이 속한 그룹으로 수정해 주면 된다.
3. find 연산은 자신이 속한 집합의 대표 노드를 찾는 연산이다. 이는 단순히 대표 노드를 찾는 역할만 하지 않고 그래프를 정돈하여 시간 복잡도를 줄여주기도 한다. find 연산의 작동 원리는 다음과 같다.
   1. 배열에서 대상 노드의 index 값과 value 값이 동일한지 확인한다.
   2. 동일하지 않으면 value 값이 가리키는 index 위치로 이동한다.
   3. 이동 위치의 index 값과 value 값이 같을 때까지 1~2를 반복한다. 이 부분은 재귀 함수 또는 스택으로 구현된다.
   4. 대표 노드에 도달하면 반복을 빠져 나오면서 거쳐가는 모든 노드의 값을 대표 노드의 값으로 변경한다.

find 연산 수행 시 같은 집합 내에 있는 모든 노드의 깊이가 재정렬되기 때문에 연속으로 같은 집합의 노드에 대해 find 연산을 수행할 경우 시간 복잡도가 O(1)로 고정된다.

## 08-3. 위상 정렬

위상 정렬(topology sort)은 사이클이 없는 방향 그래프에서 노드 순서를 찾는 알고리즘이다.

| 기능 | 특징 | 시간 복잡도(노드 수: V, 에지 수: E) |
| :-- | :-- | :-- |
| 노드 간의 순서를 결정 | 사이클이 없어야 함 | O(V + E) |

위상 정렬에서는 항상 유일한 값으로 정렬되지 않는다. 또한 사이클이 존재하면 노드 간의 순서를 명확하게 정의할 수 없으므로 위상 정렬을 적용할 수 없다.

### 위상 정렬의 핵심 이론

#### 위상 정렬의 원리 이해하기

1. 진입 차수(in-degree)는 자기 자신을 가리키는 에지의 개수이다. 진입 차수 배열 D를 정의하고, 에지를 추가할 때마다 도착 노드의 진입 차수 배열 값을 1씩 더한다.
2. 진입 차수 배열에서 진입 차수가 0인 노드를 선택하고 선택된 노드를 정렬 배열에 저장한다. 그 후 인접 리스트에서 선택된 노드가 가리키는 노드들의 진입 차수를 1씩 뺀다. 그 다음으로 선택된 노드가 가리키는 노드들을 기준으로 다시 그 노드가 가리키는 노드들의 진입 차수를 1씩 빼는 것을 반복한다. 이때 어떤 노드를 먼저 선택하냐에 따라 정렬 방식이 바뀔 수 있기 때문에 위상 정렬에서는 항상 유일한 값으로 정렬되지 않는다.

