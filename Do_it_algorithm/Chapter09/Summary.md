# 09. 트리

## 09-1. 트리 알아보기

트리(tree)는 노드와 에지로 연결된 그래프의 특수한 형태로 주요 특징은 다음과 같다.

- 순환 구조(cycle)를 지니고 있지 않고, 1개의 루트 노드가 존재한다.
- 루트 노드를 제외한 노드는 단 1개의 부모 노드를 갖는다.
- 트리의 부분 트리(subtree) 역시 트리의 모든 특징을 따른다.

### 트리의 핵심 이론

| 구성 요소 | 설명 |
| :--: | :-- |
| 노드 | 데이터의 index와 value를 표현하는 요소 |
| 에지 | 노드와 노드의 연결 관계를 나타내는 선 |
| 루트 노드 | 트리에서 가장 상단에 존재하는 노드 |
| 부모 노드 | 두 노드 사이의 관계에서 상위 노드에 해당하는 노드 |
| 자식 노드 | 두 노드 사이의 관계에서 하위 노드에 해당하는 노드 |
| 리프 노드 | 트리에서 가장 하단에 존재하는 노드(자식 노드가 없는 노드) |
| 서브 트리 | 전체 트리에 속한 작은 트리 |


## 09-2. 트라이

트라이(trie)는 검색을 빠르게 실행할 수 있도록 설계된 트리 형태의 자료구조이다.

### 트라이의 핵심 이론

트라이는 일반적으로 단어들을 사전의 형태로 생성한 후 트리의 부모 자식 노드 관계를 이용해 검색을 수행한다. 특징은 다음과 같다.

- N진 트리: 문자 종류의 개수에 따라 N이 결정된다. 예를 들어 알파벳은 26개의 문자로 이루어져 있으므로 26진 트리로 구성된다.
- 루트 노드는 항상 빈 문자열을 의미하는 공백 상태를 유지한다.

## 09-3. 이진 트리

이진 트리(binary tree)는 각 노드의 자식 노드의 개수(차수)가 2 이하로 구성된 트리이다.

### 이진 트리의 핵심 이론

#### 이진 트리의 종류

이진 트리에는 편향 이진 트리, 포화 이진 트리, 완전 이진 트리가 있다.

- 편향 이진 트리: 노드들이 한쪽으로 편향되어 생성된 이진 트리이다.
- 포화 이진 트리: 트리의 높이가 모두 일정하며 리프 노드가 꽉 찬 이진 트리이다.
- 완전 이진 트리: 마지막 레벨을 제외하고 완전하게 노드들이 채워져 있고, 마지막 레벨은 왼쪽부터 채워진 이진 트리이다.

#### 이진 트리의 순차 표현

가장 직관적이면서 편리한 트리 자료구조 형태는 배열이다. 이진 트리를 1차원 배열의 형태로 표현할 때 트리의 노드와 배열의 인덱스 간의 관계는 다음과 같다.

| 이동 목표 노드 | 인덱스 연산 | 제약 조건(N = 노드 개수) |
| :-- | :-- | :-- |
| 루트 노드 | index = 1 | |
| 부모 노드 | index = index / 2 | 현재 노드가 루트 노드가 아니어야 함 |
| 왼쪽 자식 노드 | index = index * 2 | index * 2 <= N |
| 오른쪽 자식 노드 | index = index * 2 + 1 | index * 2 + 1 <= N |

## 09-4. 세그먼트 트리

세그먼트 트리는 주어진 데이터의 구간 합과 데이터 업데이트를 빠르게 수행하기 위해 고안된 자료구조이다. 더 큰 범위는 인덱스 트리라고 불린다.

### 세그먼트 트리의 핵심 이론

세그먼트 트리의 종류는 구간 합, 최대/최소 구하기로 나눌 수 있다. 구현 단계는 다음과 같다.

1. 트리 초기화하기: 리프 노드의 개수가 데이터의 개수(N) 이상이 되도록 트리 배열을 만든다. 트리 배열의 크기는 2^k >= N을 만족하는 k의 최솟값에 대해 2^k * 2로 설정하면 된다. 이후 2^k를 시작 인덱스로 하여 리프 노드에 데이터를 채운다. 그리고 부모 노드의 값은 구간 합이면 자식 노드의 합, 최대면 자식 노드 중 최대인 것, 최소면 자식 노드 중 최소인 것으로 채운다.
2. 질의값 구하기: 주어진 질의 인덱스를 `세그먼트 트리 index = 질의 index + 2^k - 1`과 같이 세그먼트 트리의 인덱스로 변환한다. 그리고 질의에서의 시작 인덱스와 종료 인덱스에 관해 부모 노드로 이동하면서 주어진 질의에 해당하는 값을 다음과 같이 구한다.
   1. `start_index % 2 == 1`일 때 해당 노드를 선택한다. 이때 start_index는 부모 노드의 오른쪽 자식 노드이므로 부모 노드가 포함되어선 안 된다.
   2. `end_index % 2 == 0`일 때 해당 노드를 선택한다. 이때 end_index는 부모 노드의 왼쪽 자식 노드이므로 부모 노드가 포함되어선 안 된다.
   3. start_index depth 변경: `start_index = (start_index + 1) / 2` 연산을 실행한다. start_index가 왼쪽 자식 노드일 경우엔 그 부모가 포함되지만, 오른쪽 자식 노드일 경우엔 포함되지 않는다.
   4. end_index depth 변경: `end_index = (end_index - 1) / 2` 연산을 실행한다. end_index가 오른쪽 자식 노드일 경우엔 그 부모가 포함되지만, 왼쪽 자식 노드일 경우엔 포함되지 않는다.
   5. 1~4를 반복하다가 `end_index < start_index`가 되면 종료한다.
3. 데이터 업데이트하기: 업데이트 방식은 자신의 부모 노드로 이동하면서 업데이트가 수행되지 않을 때까지 값을 수정하는 것이다. 그러나 어떤 값으로 업데이트할 것인지는 트리 타입별로 조금 다르다. 구간 합에서는 원래 데이터와 변경 데이터의 차이만큼을 부모 노드의 값을 변경해 나간다. 최댓값/최솟값 찾기에서는 변경된 노드의 형제 노드와 값을 비교해 최대/최소인 것으로 부모 노드의 값을 변경한다.

질의에 해당하는 노드를 선택하는 방법은 구간 합, 최댓값 구하기, 최솟값 구하기 모두 동일하며 선택된 노드들에 관해 마지막에 연산하는 방식만 다르다.

- 구간 합: 선택된 노드를 모두 더한다.
- 최댓값 구하기: 선택된 노드 중 MAX값을 선택한다.
- 최솟값 구하기: 선택된 노드 중 MIN값을 선택한다.

## 09-5. 최소 공통 조상

트리 그래프에서 임의의 두 노드를 선택했을 때 두 노드가 각각 자신을 포함해 거슬러 올라가면서 부모 노드를 탐색할 때 처음 공통으로 만나게 되는 부모 노드를 최소 공통 조상(LCA: lowest common ancestor)이라고 한다.

### 최소 공통 조상의 핵심 이론

#### 일반적인 최소 공통 조상 구하기

먼저 루트에서 탐색을 시작해 각 노드의 부모 노드와 깊이를 저장한다. 이후 선택된 두 노드의 깊이가 다른 경우 깊이를 같게 맞춰준다. 그리고 깊이를 하나씩 올리며 두 노드가 같은 노드를 가리킬 때까지 반복하면 된다. 이 방식을 사용하면 시간 복잡도가 트리 높이에 의존적이게 된다.

#### 최소 공통 조상 빠르게 구하기

핵심은 서로의 깊이를 맞춰 주거나 공통 조상을 찾을 때 2^k씩 올라가 비교하는 것이다. 이 알고리즘은 다음의 3단계로 이루어진다.

1. 부모 노드 저장 배열 만들기: 부모 노드 배열이란 `P[K][N] = N번 노드의 2^k번째 부모의 노드 번호`를 만족하는 배열 P이다. 부모 노드 배열의 점화식은 `P[K][N] = P[K-1][P[K-1][N]]`이다. 점화식은 N의 2^k번째 부모 노드는 N의 2^(k-1)번째 부모 노드의 2^(k-1)번째 부모 노드라는 의미이다. K의 최댓값은 `트리의 깊이 > 2^K`를 만족하는 최댓값이다.
2. 선택된 두 노드의 깊이 맞추기: 더 깊이 있는 노드의 깊이를 2^k 단위로 조정하면서 맞춘다. 예를 들어 깊이 차이가 20이라면 2^4 + 2^2처럼 2회 이동하여 맞출 수 있다.
3. 최소 공통 조상 찾기: 두 노드 모두 깊이를 2^k씩 조정해 가며 최초로 두 노드의 부모가 달라지는 지점을 찾는다. 부모 노드 배열에서 K 값을 1씩 감소시켜 나가면 된다. 이를 k가 0이 될 때까지 반복한 후 두 노드가 같으면 해당 노드가, 다르면 해당 노드들의 부모 노드가 최소 공통 조상이 된다.