# 07. 정수론

## 07-1. 소수 구하기

소수(prime number)는 1보다 큰 자연수 중 자신보다 작은 2개의 자연수를 곱해 만들 수 없는 자연수를 말한다. 즉, 1과 자기 자신 외에 약수가 존재하지 않는 자연수이다.

### 소수 구하기의 핵심 이론

소수를 구하는 대표적인 판별법은 에라토스테네스의 체가 있다. 원리는 다음과 같다.

1. 구하고자 하는 소수의 범위만큼 1차원 배열을 생성한다.
2. 2부터 시작하고 현재 숫자가 지워진 상태가 아닌 경우 현재 선택된 숫자의 배수에 해당하는 수를 배열에서 끝까지 탐색하면서 지운다. 이때 처음으로 선택된 숫자는 지우지 않는다.
3. 배열의 끝까지 2를 반복한 후 배열에 남은 모든 수를 출력한다.

일반적으로 에라토스테네스의 체를 구현할 때 이중 for문을 사용하기 때문에 시간 복잡도가 O(N²) 정도라고 판단할 수 있다. 그러나 일반적으로 O(Nlog(logN))의 시간 복잡도를 보인다. 이는 안쪽 for문에서 배수를 삭제하는 연산으로 인해 바깥쪽 for문이 상당히 생략되기 때문이다.

## 07-2. 오일러 피

오일러 피 함수 P[N]의 정의는 1부터 N까지 범위에서 N과 서로소인 자연수의 개수를 뜻한다.

### 오일러 피의 핵심 이론

1. 구하고자 하는 오일러 피의 범위만큼 배열을 자기 자신의 인덱스 값으로 초기화한다.
2. 2부터 시작해 현재 배열의 값과 인덱스가 같은 경우(즉, 소수인 경우) 현재 선택된 숫자(K)의 배수에 해당하는 수를 배열에서 끝까지 탐색하며 P[i] -= (P[i] / K) 연산을 수행한다(i는 K의 배수).
3. 배열의 끝까지 2를 반복하여 오일러 피 함수를 완성한다.

즉, 합성수는 자기 자신을 소인수로 나눈 수만큼의 개수의 수들이 서로소를 이루지 못하게 하고, 소수는 오직 자기 자신만이 서로소를 이루지 못하게 한다. 그러므로 이러한 경우들을 제외시켜주는 로직이라고 볼 수 있다.

### 오일러 피 함수의 원리 이해하기

예를 들어, 6의 오일러 피 함수를 계산할 때의 과정은 다음과 같다.

1. 2의 배수 중 6이 있기 때문에 6 -= (6 / 2) 연산에 의해 P[6] = 3이 된다.
2. 3의 배수 중 6이 있기 때문에 3 -= (3 / 3) 연산에 의해 P[6] = 2가 된다.

이때, 변경된 P[6]의 값을 사용해 같은 연산을 진행하는 것은 6이 2와 3의 공배수이기 때문에 중복하여 수를 제거하는 경우를 방지하는 것으로 이해할 수 있다.

## 07-3. 유클리드 호제법

유클리드 호제법(euclidean-algorithm)은 두 수의 최대 공약수를 구하는 알고리즘이다.

### 유클리드 호제법의 핵심 이론

MOD 연산을 사용해 3단계로 유클리드 호제법을 구현할 수 있다.

1. 큰 수를 작은 수로 나누는 MOD 연산을 수행한다.
2. 앞 단계에서의 작은 수와 MOD 연산 결괏값(나머지)으로 MOD 연산을 수행한다.
3. 단계 2를 반복하다가 나머지가 0이 되는 순간의 작은 수를 최대 공약수로 선택한다.

## 07-4. 확장 유클리드 호제법

확장 유클리드 호제법의 목적은 방정식의 해를 구하는 것이다.

### 확장 유클리드 호제법의 핵심 이론

확장 유클리드 호제법에서 해를 구하고자 하는 방정식은 다음과 같다.

```
ax + by = c(a, b, c, x, y는 정수)
```

이때 위 방정식은 c % gcd(a, b) = 0인 경우에만 정수해를 가진다. 다시 말해 c가 a와 b의 최대 공약수의 배수인 경우에만 정수해를 가진다. 이는 ax + by = c가 정수해를 갖게 하는 c의 최솟값이 gcd(a, b)라는 것을 의미한다. 구현에는 재귀 함수를 사용한다.

#### 확장 유클리드 호제법의 원리 이해하기

5x + 9y = 2일 때 이 식을 만족하는 정수 x, y를 구한다.

1. 우선 5x + 9y가 정수해를 갖게 하는 c의 최솟값이 gcd(5, 9)라는 것을 적용하여 식을 다시 놓는다. gcd(5, 9) = 1이므로 5x + 9y = 1로 식을 다시 놓고 다음 단계를 진행한다.
2. a, b로 유클리드 호제법을 반복 실행하며 몫, 나머지를 저장한다. 반복은 나머지가 0이 되면 중단한다.
3. 반복으로 구한 나머지와 몫을 이용하여 거꾸로 올라가며 x = y', y = x' - y' * q를 계산한다. x'는 이전의 x, y'는 이전의 y, q는 현재 보고 있는 몫을 의미한다. 이때 x, y의 초기값은 각각 1, 0으로 지정한다.
4. 이렇게 재귀 방식으로 알아낸 최종 x, y는 ax + by = gcd(a, b)를 만족한다. 그리고 c / gcd(a, b) = K를 가정하면 최초 방정식의 해는 Kx, Ky로 간단히 구할 수 있다.
